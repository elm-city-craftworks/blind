#!/usr/bin/env ruby

require 'ray'
require 'optparse'

require_relative "../lib/blind"

options = {}
option_parser = OptionParser.new do |opts|

  options[:mines] = 30
  opts.on("-n MINES",
          ('1'..'60').to_a,
          "Number of mines, between 1 and 60") do |num_mines|

    # NOTE: This is a workaround for problem I spotted with having more
    # than 64 sounds in the game playing simultaneously!
    options[:num_mines] = num_mines.to_i
  end

end

option_parser.parse!
num_mines = options[:num_mines]

# Take care of some initial boilerplate for the game

game    = Blind::UI::GamePresenter.new(num_mines)
message = "Find the phone, avoid the beeping mines and the sirens\n"+
          "(Use WASD keys to move)"

Ray::Audio.pos = [0,0,0]

# Begin the actual Ray program. Most interesting work
# gets delegated to the Blind::UI::GameDecorator object

Ray.game "Blind" do
  register { add_hook :quit, method(:exit!) }

  scene :main do
    self.frames_per_second = 10

    add_hook :quit, method(:exit!)

    always do
      if game.finished?
        message = game.game_over_message
      else
        game.detect_danger_zone

        game.move( 0.0, -0.2)  if holding?(:w)
        game.move( 0.0,  0.2)  if holding?(:s)
        game.move(-0.2,  0.0)  if holding?(:a)
        game.move( 0.2,  0.0)  if holding?(:d)

        position = game.player_position

        Ray::Audio.pos = [position.x, position.y, 0]
      end
    end

    render do |win|
      win.draw(text(message, :size => 20, :at => [30,30]))
      win.draw(text(game.to_s, :at => [30, 200])) if $DEBUG
     end
  end

  scenes << :main
end
